@typeparam TItem where TItem : class
@using System.Diagnostics.CodeAnalysis

@if (Readonly) {
    <div class="editable editable-readonly" style="display: contents">
        @ReadTemplate
    </div>
}
else if (_isEditMode && !Readonly)
{
    <div class="editable editable-editing" style="display: contents" @onkeydown="HandleKeyDown">
        @EditTemplate(_itemCopy)
        <div class="actions">
            <button type="button" @onclick="Save">
                <Blazicon Svg="Lucide.Save" />
            </button>
            <button type="button" @onclick="CancelEditMode">
                <Blazicon Svg="Lucide.X" />
            </button>
        </div>
    </div>
}
else
{
    <div class="editable editable-read" style="display: contents">
        @ReadTemplate
        <div class="actions">
            <button type="button" @onclick="StartEditMode">
                <Blazicon Svg="Lucide.Pencil" />
            </button>
            @if(CanDelete)
            {
                <button type="button" @onclick="Delete">
                    <Blazicon Svg="Lucide.Trash2" />
                </button>
            }
        </div>
    </div>
}

@code {
    
    [Parameter]
    [NotNull]
    public RenderFragment? ReadTemplate { get; set; }
    
    [Parameter]
    [NotNull]
    public RenderFragment<TItem>? EditTemplate { get; set; }
    
    [Parameter]
    public EventCallback<OnActionCompletedArgs<TItem>> OnActionCompleted { get; set; }

    [Parameter]
    public bool Readonly { get; set; }

    [Parameter]
    public bool CanDelete { get; set; } = true;
    
    [Parameter]
    [NotNull]
    public TItem? Item { get; set; }
    
    [CascadingParameter]
    [NotNull]
    public EditContext? EditContext { get; set; }

    private TItem _itemCopy = default!;
    
    bool _isEditMode;
    private void StartEditMode()
    {
        if (Item == null)
        {
            throw new ArgumentException("Item is null");
        }
        
        var memberwiseClone = typeof(object).GetMethod("MemberwiseClone",
            System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

        // This should never fail, so I'm going to let it fly for now.
        _itemCopy = (TItem)memberwiseClone!.Invoke(Item, null)!;
        _isEditMode = true;
        
        EditContext = new EditContext(_itemCopy);
    }
    
    private void CancelEditMode()
    {
        _isEditMode = false;
    }
    
    private async Task Delete()
    {
        await OnActionCompleted.InvokeAsync(new OnActionCompletedArgs<TItem>(ActionType.Delete, Item));
    }
    
    private async Task Save()
    {
        await OnActionCompleted.InvokeAsync(new OnActionCompletedArgs<TItem>(ActionType.Save, _itemCopy));
        _isEditMode = false;
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await Save();
        }
    }
}
